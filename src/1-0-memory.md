# 内存控制

<!-- 增加性能和瓶颈更泛化的叙述， -->

程序员常常会问自己这样一个问题，如何提高我的程序的性能？有个有点偷懒但很有效的答案，就是寻找当前的**性能瓶颈**并优化它。更具体一点说，性能瓶颈一般在哪呢？第一有可能的瓶颈自然是算法，但第二可能便是内存控制了。

> 程序 = 算法 + 数据结构 （或者更简单的版本：**程序 = 过程 + 数据**）

除了性能问题之外，程序员希望对内存有更精细的控制的场合还有很多。但长久以来，系统程序员似乎面临着这样的困境：在现有的语言中，选择了更多更底层的控制，就意味着更容易出错；而选择了安全保障，则意味着更少控制。类似的抉择常常在是否要垃圾回收上体现：选择垃圾回收，你可以获得对内存访问的更多保障，如没有内存泄露问题，也没有悬垂指针、二次释放等广泛存在的内存安全问题，但你也因此无法直接触碰内存、控制内存的排布，无法决定何时回收垃圾，从而失去了一些优化的可能（编译器或虚拟机有时会帮你优化，你也可以通过编码技巧来促进这种优化，但终究比较间接）。

我们不禁要问，底层控制和安全性真的无法同时保障吗？可以明确的事，越接近底层控制，程序员越需要对底层深入了解，面对的状况也越复杂。但复杂性并不直接意味着失去安全性，仅仅是提供安全保障也不意味着削弱控制。也就是说底层控制和安全保障并不是直接冲突的。我们真正需要解决的是复杂性的问题。

泛泛而言，复杂性导致出错不外乎如下几个原因：

* 对复杂性理解不足；
* 繁琐的细节中出错；
* 疲于应付繁琐细节、导致逻辑出错。

解决问题也应该是对症下药，通过明确化来直面复杂性，和通过抽象来解决复杂性。

**直面复杂性**：复杂性越直接暴露，也就越能促使程序员深入了解背后发生了什么。系统编程最为复杂的部分便是内存控制。因而，本章节将介绍内存机制如何在 rust 中显式呈现、不同的内存操作对操作对象有何要求、以及 rust 所提供的不同层次的安全保障和所要付出代价之间的显式权衡，最后以并发编程为例，展示这种明确化的潜在力量。

**解决复杂性**：几乎每一本计算机科学的书都会谈到，解决复杂性最佳方式是抽象，而 rust 的抽象机制将在后续章节中介绍。

<!--
参考：
https://doc.rust-lang.org/nomicon/index.html
https://docs.rust-embedded.org/book/static-guarantees/index.html
https://doc.rust-lang.org/1.5.0/book/choosing-your-guarantees.html
-->
